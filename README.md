# java-google-style-guide-translate-rus
Переработанный документ:
Файлы, пакеты
Имена классов должны быть существительными, первые буквы всех слов — заглавные.
Имена папок, файлов и пакетов состоят только из строчных букв. Слова в многословных названиях разделяются подчеркиванием
Используйте UTF-8,  как кодировку для Ваших исходных файлов
Описание файла должно быть в самом начале. Далее идут объявления операторов package и import, причем каждый блок разделяется пустой строкой.
Отступы, длина строки, переносы строк
Отступы должны составлять строго 4 пробельных символа (ASCII, 0x20)
Символы табуляции не используются для отступов 
Длина строки не должна превышать 100 символов.
При превышении длины строки, выражение разбивается согласно следующим правилам:
перенос после запятой;
перенос перед оператором;
используйте отступ в 8 пробелов для обозначения второй строки разделенного выражения. 
Последующие строки выравниваются по второй строке либо добавляются новые 8 пробелов для обозначения вложенности.
Пример:
int result = someLongExpression(this, expression, on, first, line)     
        + someLongExpression(this, expression, on, seccond, line) 
Расположение блоков, операторов, пробелы, скобки
Определение переменных нужно располагать в начале блока, а не «ждать» первого использования переменной. Инициализация должна производиться, по возможности, сразу.
void myMethod() {
    int count = 0; // beginning of method block
    if (condition) {
        int int2; // beginning of "if" block
        ...
    }
}
Между именем метода и скобками для списка параметров нет пробела.
getStaffList(String name)
Параметры разделяются пробелом.
getStaffList(String name, int count)

Пробелы окружают любой оператор.
res = getCount();
(a > 10) ? b : c;
Ключевое слово и следующая за ним скобка ( должны разделяться пробелом.
while (b < 100) {
    …
}
Открывающаяся скобка { располагается на той же строке, что и сигнатура метода/заголовок if, while-блока и т.п.
Закрывающаяся скобка } выровнена по строке начала данного блока.
public Collection getStaffList(String name) {
    Collection contacts = Contact.getList(name, RoleHelper.ROLE_AGENT, null,
    AccessLevel.getStaffDiaryEditLevel(), 0, MAX_NUMBER);
    return ListHelper.getLabelValueList(contacts);
}
Методы разделяются пустой строкой, объявления свойств класса располагаются по одному на строку.
На строке располагается только один оператор.
if (b) {
    return result;
}
Имена методов, переменных
Названия методов должны быть глаголами, первая буква должна быть строчной, первые буквы внутренних слов — заглавные.
Имена переменных должны начинаться со строчной буквы, внутренние слова — с заглавной.
Придерживайтесь следующих названий полей:
Не static и не public имена начинаются c «m».
static поля начинаются с «s».
Другие поля начинаются с буквы нижнего регистра.
Поля public static final (константы) пишутся полностью в верхнем регистре, с использованием подчеркивания (ALL_CAPS_WITH_UNDERSCORES)
Структурирование кода
Методы должны быть короткими, и выполнять только одну задачу (к примеру, почти любой цикл уже достоин того, чтобы вынести его в особый метод).
Имена методов должны быть самодокументированными.
Шаблоны ООП должны применяться для структурирования и облегчения восприятия.
Комментарии/Javadoc
Описание файла в самом начале. - комментарий.
Каждый класс описывайте в Javadoc, по крайней мере с одной фразой, описывающей что он делает. Начинайте фразу с описательного глагола 3-го лица. 
Не нужно описывать Javadoc для тривиальных get и set методов
Если метод делает что-то более сложное (например, соблюдение неких ограничений, или если его действия имеют важный эффект вне его самого), тогда его обязательно нужно задокументировать.Вообще, любой метод, полезно описывать в Javadoc, неважно public он или нет. Public методы являются частью API, и поэтому они требуют описания в Javadoc
Стиль TODO. Используйте комментарии TODO для кода, который является временным, краткосрочным, или хорошим, но не идеальным. Комментарий должен включать в себя «TODO:», например:
// TODO: Remove this code after the UrlTable2 has been checked in.

// TODO: Change this to use a flag instead of a constant.
Если ваш комментарий имеет вид «В будущем сделать что-то», то убедитесь, что он включает в себя конкретную дату (1 января 2011 года), или конкретное событие «Удалить после выхода версии 2.1».
Импорты
Порядок операторов импорта следующий:
Android импорты.
Сторонние импорты (com, junit, net, org).
java и javax.

Для полного соответствия настройкам IDE, импорты должны иметь следующий вид:
Отсортированы по алфавиту внутри каждой группы.
Заглавные буквы должны быть впереди букв нижнего регистра (например, Z перед a).
Главные группы должны разделяться пустой строкой.
Локальные переменные
Область видимости локальных переменных должна сводиться к минимуму. Делая это, вы улучшаете читаемость и поддерживаемость кода, а также уменьшаете вероятность ошибок.
Каждая переменная должна объявляться в самом глубоком блоке, который окружает все возможные места использования переменной.

Локальные переменные должны объявляться в том месте, где впервые необходимо её использовать. 
Почти каждая локальная переменная нуждается в инициализаторе. 
Отложите объявление локальной переменной, пока вы не узнаете, как ее инициализировать.

! Исключение:
Это исключение касается блока try-catch. Если переменная инициализируется при помощи оператора return метода, который выбрасывает проверяемое исключение, то она должна инициализироваться в блоке try. Если же переменная должна использоваться вне блока try, тогда она объявляется перед ним, неважно, знаете ли вы, как её нужно инициализировать, или нет:
// Instantiate class cl, which represents some sort of Set 
Set s = null;
try {
    s = (Set) cl.newInstance();
} catch(IllegalAccessException e) {
    throw new IllegalArgumentException(cl + " not accessible");
} catch(InstantiationException e) {
    throw new IllegalArgumentException(cl + " not instantiable");
}

// Exercise the set 
s.addAll(Arrays.asList(args));



Однако этот случай можно обойти при помощи инкапсуляции блока try-catch в методе.
Set createSet(Class cl) {
    // Instantiate class cl, which represents some sort of Set 
    try {
        return (Set) cl.newInstance();
    } catch(IllegalAccessException e) {
        throw new IllegalArgumentException(cl + " not accessible");
    } catch(InstantiationException e) {
        throw new IllegalArgumentException(cl + " not instantiable");
    }
}

...

// Exercise the set 
Set s = createSet(cl);
s.addAll(Arrays.asList(args));





Переменные в циклах должны объявляться внутри самого оператора, если только нет непреодолимой причины этого не делать.
for (int i = 0; i <= n; i++) {
    doSomething(i);
}

for (Iterator i = c.iterator(); i.hasNext(); ) {
    doSomethingElse(i.next());
}
Исключения
Не игнорируйте исключения.  Вы в принципе должны обрабатывать каждое исключение. Специфика в каждом конкретном случае зависит от ситуации.
Плохо:
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) { }
}


Приемлемые альтернативы:
Перебрасывайте исключения к вызывающему методу
void setServerPort(String value) throws NumberFormatException {
    serverPort = Integer.parseInt(value);
}


 Выбрасывайте исключения, соответственно вашему уровню абстракции
void setServerPort(String value) throws ConfigurationException {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        throw new ConfigurationException("Port " + value + " is not valid.");
    }
}


Перехватите ошибку и замените соответствующее значение в блоке catch{}
/** Set port. If value is not a valid number, 80 is substituted. */
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        serverPort = 80;  // default port for server 
    }
}


Перехватите ошибку и выбросьте RuntimeException. Это опасно: делайте это только если вам все равно случится ли эта ошибка.
/** Set port. If value is not a valid number, die. */
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        throw new RuntimeException("port " + value " is invalid, ", e);
    }
}


Заметьте, что изначальное исключение передается конструктору RuntimeException. Если вы используете компилятор Java 1.3, то опустите исключение.
Если вы уверены в том, что игнорирование исключения в этом случае имеет место, то хотя бы прокомментируйте, почему вы так решили.
/** If value is not a valid number, original port number is used. */
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        // Method is documented to just ignore invalid user input.
        // serverPort will just be unchanged.
    }
}



Не перехватывайте обобщенные исключения. Суть в том, что возможно появление исключения, которого вы не ожидали и, в итоге, ошибка будет отлавливаться на уровне приложения. То есть, если кто-то добавит новый тип исключения, то компилятор не сможет вам помочь понять, что это другая ошибка.
Плохо:
try {
    someComplicatedIOFunction();        // may throw IOException 
    someComplicatedParsingFunction();   // may throw ParsingException 
    someComplicatedSecurityFunction();  // may throw SecurityException 
    // phew, made it all the way 
} catch (Exception e) {               // I'll just catch all exceptions 
    handleError();                      // with one generic handler!
}


Альтернативы обобщенным исключениям:
Предпочтительный способ для перехвата всех исключений: перехватывать каждое исключение отдельно в блоке catch, после одиночного try
Измените ваш код так, чтобы обрабатывать ошибки отдельно для каждого случая.
Перебросьте исключение. Во многих случаях вам не нужно обрабатывать все исключения на текущем уровне, просто позвольте методу перебросить их.
Финализаторы

Финализаторы — это способ запускать программный код перед тем как объект собирается сборщиком мусора.

За: 
могут быть полезны при очистке, в особенности внешних ресурсов.

Против: 
нет никаких гарантий того, когда будет вызван финализатор, и, вообще, будет ли он вызван.

Вывод: 
В большинстве случаев, всё то, что вам нужно от финализатора, вы можете сделать при помощи обработки исключений. Если вам действительно нужен финализатор, то объявите метод close() и задокументируйте, когда он точно будет вызываться.

